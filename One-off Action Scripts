// scripts/export-zendesk-full-config.js - Complete Zendesk Configuration Export
require('dotenv').config();
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const config = require('../config/zendesk');
const { validateEnvironment } = require('../config/validate');

class ZendeskFullConfigExporter {
  constructor() {
    this.baseURL = `https://${config.zendesk.domain}/api/v2`;
    this.authString = config.zendesk.getAuthString();
    this.headers = {
      'Authorization': `Basic ${Buffer.from(this.authString).toString('base64')}`,
      'Content-Type': 'application/json'
    };
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.exportData = {
      export_info: {
        timestamp: new Date().toISOString(),
        zendesk_domain: config.zendesk.domain,
        exported_by: 'Zendesk Full Configuration Export Tool',
        version: '1.0.0'
      }
    };
    this.stats = {};
  }

  async makeRequest(endpoint, description) {
    console.log(`üîç Fetching ${description}...`);
    try {
      const response = await axios.get(`${this.baseURL}${endpoint}`, { 
        headers: this.headers 
      });
      
      // Handle pagination automatically
      let allData = response.data;
      const dataKey = Object.keys(response.data).find(key => 
        Array.isArray(response.data[key]) && key !== 'facets'
      );
      
      if (dataKey && response.data.next_page) {
        let nextUrl = response.data.next_page;
        while (nextUrl) {
          console.log(`üìÑ Fetching next page for ${description}...`);
          const nextResponse = await axios.get(nextUrl, { headers: this.headers });
          allData[dataKey] = allData[dataKey].concat(nextResponse.data[dataKey]);
          nextUrl = nextResponse.data.next_page;
          
          // Rate limiting
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      const count = dataKey ? allData[dataKey].length : 1;
      console.log(`‚úÖ Fetched ${count} ${description}`);
      return allData;
      
    } catch (error) {
      console.error(`‚ùå Error fetching ${description}:`, error.response?.data?.error || error.message);
      return null;
    }
  }

  async exportViews() {
    const data = await this.makeRequest('/views.json', 'Views');
    if (data) {
      this.exportData.views = data.views;
      this.stats.views = data.views.length;
      
      // Get detailed view data for important views
      console.log('üîç Enriching view data...');
      for (let i = 0; i < Math.min(data.views.length, 50); i++) {
        try {
          const detailResponse = await this.makeRequest(`/views/${data.views[i].id}.json`, `View Details ${i+1}`);
          if (detailResponse) {
            Object.assign(this.exportData.views[i], detailResponse.view);
          }
          await new Promise(resolve => setTimeout(resolve, 50));
        } catch (error) {
          console.log(`‚ö†Ô∏è Could not enrich view ${data.views[i].id}`);
        }
      }
    }
  }

  async exportMacros() {
    const data = await this.makeRequest('/macros.json', 'Macros');
    if (data) {
      this.exportData.macros = data.macros;
      this.stats.macros = data.macros.length;
    }
  }

  async exportTriggers() {
    const data = await this.makeRequest('/triggers.json', 'Triggers');
    if (data) {
      this.exportData.triggers = data.triggers;
      this.stats.triggers = data.triggers.length;
    }
  }

  async exportAutomations() {
    const data = await this.makeRequest('/automations.json', 'Automations');
    if (data) {
      this.exportData.automations = data.automations;
      this.stats.automations = data.automations.length;
    }
  }

  async exportTicketFields() {
    const data = await this.makeRequest('/ticket_fields.json', 'Ticket Fields');
    if (data) {
      this.exportData.ticket_fields = data.ticket_fields;
      this.stats.ticket_fields = data.ticket_fields.length;
    }
  }

  async exportTicketForms() {
    const data = await this.makeRequest('/ticket_forms.json', 'Ticket Forms');
    if (data) {
      this.exportData.ticket_forms = data.ticket_forms;
      this.stats.ticket_forms = data.ticket_forms.length;
    }
  }

  async exportUserFields() {
    const data = await this.makeRequest('/user_fields.json', 'User Fields');
    if (data) {
      this.exportData.user_fields = data.user_fields;
      this.stats.user_fields = data.user_fields.length;
    }
  }

  async exportOrganizationFields() {
    const data = await this.makeRequest('/organization_fields.json', 'Organization Fields');
    if (data) {
      this.exportData.organization_fields = data.organization_fields;
      this.stats.organization_fields = data.organization_fields.length;
    }
  }

  async exportGroups() {
    const data = await this.makeRequest('/groups.json', 'Groups');
    if (data) {
      this.exportData.groups = data.groups;
      this.stats.groups = data.groups.length;
    }
  }

  async exportSLAPolicies() {
    const data = await this.makeRequest('/slas/policies.json', 'SLA Policies');
    if (data) {
      this.exportData.sla_policies = data.sla_policies;
      this.stats.sla_policies = data.sla_policies.length;
    }
  }

  async exportBrands() {
    const data = await this.makeRequest('/brands.json', 'Brands');
    if (data) {
      this.exportData.brands = data.brands;
      this.stats.brands = data.brands.length;
    }
  }

  async exportBusinessRules() {
    // Try to get business rules if available
    const data = await this.makeRequest('/business_rules.json', 'Business Rules');
    if (data) {
      this.exportData.business_rules = data.business_rules;
      this.stats.business_rules = data.business_rules.length;
    }
  }

  async exportCustomObjects() {
    const data = await this.makeRequest('/custom_objects.json', 'Custom Objects');
    if (data) {
      this.exportData.custom_objects = data.custom_objects;
      this.stats.custom_objects = data.custom_objects.length;
    }
  }

  async exportWebhooks() {
    const data = await this.makeRequest('/webhooks.json', 'Webhooks');
    if (data) {
      this.exportData.webhooks = data.webhooks;
      this.stats.webhooks = data.webhooks.length;
    }
  }

  async exportTargets() {
    const data = await this.makeRequest('/targets.json', 'Targets');
    if (data) {
      this.exportData.targets = data.targets;
      this.stats.targets = data.targets.length;
    }
  }

  async exportExtensions() {
    const data = await this.makeRequest('/extensions.json', 'Extensions');
    if (data) {
      this.exportData.extensions = data.extensions;
      this.stats.extensions = data.extensions.length;
    }
  }

  async exportWorkspaces() {
    const data = await this.makeRequest('/workspaces.json', 'Workspaces');
    if (data) {
      this.exportData.workspaces = data.workspaces;
      this.stats.workspaces = data.workspaces.length;
    }
  }

  async exportAgents() {
    const data = await this.makeRequest('/users.json?role=agent', 'Agents');
    if (data) {
      this.exportData.agents = data.users;
      this.stats.agents = data.users.length;
    }
  }

  async exportAdmins() {
    const data = await this.makeRequest('/users.json?role=admin', 'Admins');
    if (data) {
      this.exportData.admins = data.users;
      this.stats.admins = data.users.length;
    }
  }

  async exportAccountSettings() {
    // Get account/instance settings
    const data = await this.makeRequest('/account/settings.json', 'Account Settings');
    if (data) {
      this.exportData.account_settings = data.settings;
    }
  }

  async exportDynamicContent() {
    const data = await this.makeRequest('/dynamic_content/items.json', 'Dynamic Content');
    if (data) {
      this.exportData.dynamic_content = data.items;
      this.stats.dynamic_content = data.items.length;
    }
  }

  async exportLocales() {
    const data = await this.makeRequest('/locales.json', 'Locales');
    if (data) {
      this.exportData.locales = data.locales;
      this.stats.locales = data.locales.length;
    }
  }

  generateSummaryReport() {
    console.log('\nüìä ZENDESK CONFIGURATION EXPORT SUMMARY');
    console.log('=' .repeat(60));
    
    let totalItems = 0;
    Object.entries(this.stats).forEach(([category, count]) => {
      console.log(`${category.replace(/_/g, ' ').toUpperCase()}: ${count}`);
      totalItems += count;
    });
    
    console.log('-' .repeat(60));
    console.log(`TOTAL CONFIGURATION ITEMS: ${totalItems}`);
    
    return {
      total_items: totalItems,
      categories: Object.keys(this.stats).length,
      breakdown: this.stats
    };
  }

  async saveExports() {
    // Ensure exports directory exists
    const exportDir = 'exports';
    if (!fs.existsSync(exportDir)) {
      fs.mkdirSync(exportDir, { recursive: true });
    }

    // Add summary to export data
    const summary = this.generateSummaryReport();
    this.exportData.export_info.summary = summary;

    // Save comprehensive JSON export
    const jsonFile = `exports/zendesk-full-config-${this.timestamp}.json`;
    fs.writeFileSync(jsonFile, JSON.stringify(this.exportData, null, 2));
    console.log(`\nüíæ Complete configuration saved to: ${jsonFile}`);

    // Save individual category files for easier analysis
    const categoryFiles = [];
    Object.entries(this.exportData).forEach(([category, data]) => {
      if (category !== 'export_info' && Array.isArray(data)) {
        const categoryFile = `exports/zendesk-${category}-${this.timestamp}.json`;
        fs.writeFileSync(categoryFile, JSON.stringify({
          export_info: this.exportData.export_info,
          [category]: data
        }, null, 2));
        categoryFiles.push(categoryFile);
      }
    });

    // Create summary CSV
    const csvFile = `exports/zendesk-config-summary-${this.timestamp}.csv`;
    let csvContent = 'Category,Count,Description\n';
    Object.entries(this.stats).forEach(([category, count]) => {
      const description = this.getCategoryDescription(category);
      csvContent += `${category},${count},"${description}"\n`;
    });
    fs.writeFileSync(csvFile, csvContent);

    return {
      mainExport: jsonFile,
      categoryFiles,
      summary: csvFile,
      stats: summary
    };
  }

  getCategoryDescription(category) {
    const descriptions = {
      views: 'Ticket views and filters for organizing customer requests',
      macros: 'Automated response templates and ticket update actions',
      triggers: 'Automated rules that fire when tickets are created/updated',
      automations: 'Time-based automated actions on tickets',
      ticket_fields: 'Custom fields available on tickets',
      ticket_forms: 'Different ticket submission forms',
      user_fields: 'Custom fields for user profiles',
      organization_fields: 'Custom fields for organization profiles',
      groups: 'Agent groups for ticket assignment and permissions',
      sla_policies: 'Service level agreement policies and targets',
      brands: 'Brand configurations for multi-brand support',
      business_rules: 'Advanced business logic and routing rules',
      custom_objects: 'Custom data objects and relationships',
      webhooks: 'HTTP callbacks for external system integration',
      targets: 'External system targets for notifications',
      extensions: 'Custom apps and integrations',
      workspaces: 'Agent workspace configurations',
      agents: 'Agent user accounts and permissions',
      admins: 'Administrator user accounts',
      account_settings: 'Global account configuration settings',
      dynamic_content: 'Multi-language dynamic content items',
      locales: 'Supported languages and localization settings'
    };
    return descriptions[category] || 'Configuration data';
  }
}

async function main() {
  try {
    console.log('üöÄ Starting Complete Zendesk Configuration Export...');
    console.log('üìã This will export ALL configuration from your Zendesk instance\n');
    
    // Validate environment
    validateEnvironment();
    
    const exporter = new ZendeskFullConfigExporter();
    
    // Export all configuration categories
    console.log('üîÑ Exporting Core Configuration...');
    await Promise.all([
      exporter.exportViews(),
      exporter.exportMacros(),
      exporter.exportTriggers(),
      exporter.exportAutomations()
    ]);
    
    console.log('\nüîÑ Exporting Fields & Forms...');
    await Promise.all([
      exporter.exportTicketFields(),
      exporter.exportTicketForms(),
      exporter.exportUserFields(),
      exporter.exportOrganizationFields()
    ]);
    
    console.log('\nüîÑ Exporting Users & Groups...');
    await Promise.all([
      exporter.exportGroups(),
      exporter.exportAgents(),
      exporter.exportAdmins()
    ]);
    
    console.log('\nüîÑ Exporting Business Rules & Policies...');
    await Promise.all([
      exporter.exportSLAPolicies(),
      exporter.exportBusinessRules(),
      exporter.exportBrands()
    ]);
    
    console.log('\nüîÑ Exporting Integrations & Extensions...');
    await Promise.all([
      exporter.exportWebhooks(),
      exporter.exportTargets(),
      exporter.exportExtensions(),
      exporter.exportCustomObjects()
    ]);
    
    console.log('\nüîÑ Exporting Additional Configuration...');
    await Promise.all([
      exporter.exportWorkspaces(),
      exporter.exportDynamicContent(),
      exporter.exportLocales(),
      exporter.exportAccountSettings()
    ]);
    
    // Save all exports
    const files = await exporter.saveExports();
    
    console.log('\n‚úÖ Complete Zendesk Configuration Export finished!');
    console.log(`üìÅ Main export file: ${files.mainExport}`);
    console.log(`üìä Summary CSV: ${files.summary}`);
    console.log(`üìÇ Individual category files: ${files.categoryFiles.length} files created`);
    console.log(`üéØ Total items exported: ${files.stats.total_items}`);
    
    return {
      exportData: exporter.exportData,
      files,
      stats: files.stats
    };
    
  } catch (error) {
    console.error('\n‚ùå Export failed:', error.message);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  }
}

// Export for use in other modules
module.exports = { ZendeskFullConfigExporter, main };

// Run if called directly
if (require.main === module) {
  main();
}
